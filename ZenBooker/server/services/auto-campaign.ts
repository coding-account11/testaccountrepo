import { storage } from "../storage";
import { generateCampaignContent } from "./gemini";

export interface AutoCampaignCategory {
  id: string;
  name: string;
  description: string;
  targetSegment: string;
  frequency: number; // days between campaigns
  businessTypes: string[];
}

export const autoCampaignCategories: AutoCampaignCategory[] = [
  {
    id: "inactive-30",
    name: "Inactive Client Win-Back",
    description: "Re-engage clients who haven't visited in 30+ days",
    targetSegment: "inactive-30",
    frequency: 14,
    businessTypes: ["all"]
  },
  {
    id: "inactive-60",
    name: "Long-term Inactive Recovery",
    description: "Reach out to clients who haven't visited in 60+ days",
    targetSegment: "inactive-60",
    frequency: 21,
    businessTypes: ["all"]
  },
  {
    id: "seasonal-promotion",
    name: "Seasonal Promotion",
    description: "Seasonal offers and promotions",
    targetSegment: "all",
    frequency: 30,
    businessTypes: ["all"]
  },
  {
    id: "new-client-welcome",
    name: "New Client Welcome",
    description: "Welcome new clients and encourage return visits",
    targetSegment: "new-clients",
    frequency: 7,
    businessTypes: ["all"]
  },
  {
    id: "loyalty-reward",
    name: "Loyalty Reward",
    description: "Reward loyal customers with special offers",
    targetSegment: "loyal-clients",
    frequency: 45,
    businessTypes: ["all"]
  }
];

export interface AutoCampaignResult {
  success: boolean;
  campaignsCreated: number;
  errors: string[];
}

class AutoCampaignService {
  // Generate auto-campaigns for a user
  async generateAutoCampaigns(userId: string): Promise<AutoCampaignResult> {
    const result: AutoCampaignResult = {
      success: true,
      campaignsCreated: 0,
      errors: []
    };

    try {
      // Get user's business profile
      const businessProfile = await storage.getBusinessProfile(userId);
      if (!businessProfile) {
        result.errors.push("Business profile not found - please complete your profile first");
        return result;
      }

      // Get existing campaigns to avoid duplicates
      const existingCampaigns = await storage.getCampaigns(userId);
      const existingAutoCampaigns = existingCampaigns.filter(c => c.isAutoGenerated);

      // Get clients
      const clients = await storage.getClients(userId);
      if (clients.length === 0) {
        result.errors.push("No clients found - please import your client list first");
        return result;
      }

      // Check each category for potential campaigns
      for (const category of autoCampaignCategories) {
        try {
          // Check if we should create a campaign for this category
          const shouldCreate = await this.shouldCreateCampaign(userId, category, existingAutoCampaigns);
          
          if (shouldCreate) {
            const campaign = await this.createAutoCampaign(userId, category, clients, businessProfile);
            if (campaign) {
              result.campaignsCreated++;
            }
          }
        } catch (error) {
          console.error(`Error generating campaign for category ${category.id}:`, error);
          result.errors.push(`Failed to generate ${category.name} campaign`);
        }
      }
    } catch (error) {
      console.error("Error generating auto-campaigns:", error);
      result.success = false;
      result.errors.push("Failed to generate auto-campaigns");
    }

    return result;
  }

  // Check if we should create a campaign for this category
  private async shouldCreateCampaign(
    userId: string, 
    category: AutoCampaignCategory, 
    existingCampaigns: any[]
  ): Promise<boolean> {
    // Check if we have a recent campaign for this category
    const recentCampaign = existingCampaigns.find(c => 
      c.autoCategory === category.id && 
      c.createdAt && 
      new Date(c.createdAt) > new Date(Date.now() - category.frequency * 24 * 60 * 60 * 1000)
    );

    if (recentCampaign) {
      return false; // Too recent, skip
    }

    // Check if we have eligible clients for this segment
    const clients = await storage.getClients(userId);
    const eligibleClients = this.getEligibleClients(clients, category.targetSegment);
    
    return eligibleClients.length > 0;
  }

  // Get eligible clients for a segment
  private getEligibleClients(clients: any[], segmentType: string): any[] {
    switch (segmentType) {
      case "inactive-30":
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        return clients.filter(client => 
          !client.lastVisit || new Date(client.lastVisit) < thirtyDaysAgo
        );
      
      case "inactive-60":
        const sixtyDaysAgo = new Date();
        sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);
        return clients.filter(client => 
          !client.lastVisit || new Date(client.lastVisit) < sixtyDaysAgo
        );
      
      case "new-clients":
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        return clients.filter(client => 
          client.createdAt && new Date(client.createdAt) > sevenDaysAgo
        );
      
      case "loyal-clients":
        return clients.filter(client => 
          client.tags?.includes("loyal") || client.tags?.includes("regular")
        );
      
      default:
        return clients;
    }
  }

  // Create an auto-campaign
  private async createAutoCampaign(
    userId: string, 
    category: AutoCampaignCategory, 
    clients: any[], 
    businessProfile: any
  ): Promise<any> {
    try {
      // Get eligible clients
      const eligibleClients = this.getEligibleClients(clients, category.targetSegment);
      
      if (eligibleClients.length === 0) {
        return null;
      }

      // Generate campaign content using AI
      const content = await generateCampaignContent({
        businessType: businessProfile.businessCategory || "service",
        campaignType: category.id,
        targetAudience: category.targetSegment,
        businessProfile: {
          businessName: businessProfile.businessName || undefined,
          businessCategory: businessProfile.businessCategory || undefined,
          location: businessProfile.location || undefined,
          brandVoice: businessProfile.brandVoice || undefined,
          shortBusinessBio: businessProfile.shortBusinessBio || undefined,
          productsServices: businessProfile.productsServices || undefined,
          businessMaterials: businessProfile.businessMaterials || undefined
        }
      });

      // Create campaign
      const campaign = await storage.createCampaign({
        userId,
        name: `Auto: ${category.name}`,
        subject: content.subject,
        body: content.body,
        audience: {
          segmentType: category.targetSegment,
          filters: {},
          clientIds: eligibleClients.map(c => c.id)
        },
        status: "draft",
        isAutoGenerated: true,
        autoCategory: category.id,
        scheduledAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // Schedule for tomorrow
      });

      return campaign;
    } catch (error) {
      console.error("Error creating auto-campaign:", error);
      return null;
    }
  }

  // Get upcoming auto-campaigns for dashboard
  async getUpcomingAutoCampaigns(userId: string): Promise<any[]> {
    try {
      const campaigns = await storage.getCampaigns(userId);
      return campaigns
        .filter(c => c.isAutoGenerated && c.status === "draft")
        .sort((a, b) => new Date(a.scheduledAt || 0).getTime() - new Date(b.scheduledAt || 0).getTime());
    } catch (error) {
      console.error("Error getting upcoming auto-campaigns:", error);
      return [];
    }
  }

  // Get next auto-campaign date
  async getNextAutoCampaignDate(userId: string): Promise<Date | null> {
    try {
      const upcomingCampaigns = await this.getUpcomingAutoCampaigns(userId);
      if (upcomingCampaigns.length > 0) {
        return new Date(upcomingCampaigns[0].scheduledAt);
      }
      return null;
    } catch (error) {
      console.error("Error getting next auto-campaign date:", error);
      return null;
    }
  }
}

export const autoCampaignService = new AutoCampaignService(); 